package com.example.examplemod.Module.EXPLOIT;

import com.example.examplemod.Module.Module;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.entity.Entity;
import net.minecraft.entity.monster.EntityZombie;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.client.event.RenderWorldLastEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;
import org.lwjgl.input.Keyboard;
import org.lwjgl.opengl.GL11;

import java.util.List;

public class TestFindFarm extends Module {
    public TestFindFarm() {
        super("FindFarm" , Keyboard.KEY_NONE, Category.EXPLOIT);
    }

    private final Minecraft mc = Minecraft.getMinecraft();
    private Entity target = null;
    private long lastZombieDeathTime = 0;
    private float targetYaw = 0;
    private float targetPitch = 0;
    private double targetSpeed = 0.2;
    private boolean isAvoidingObstacle = false;
    private Vec3d lastPosition = null;

    @SubscribeEvent
    public void onPlayerTick(TickEvent.PlayerTickEvent event) {
        if (!this.isEnabled() || mc.player == null || mc.world == null) return; // Проверяем, включен ли модуль


        if (target != null && target.isDead) {
            if (System.currentTimeMillis() - lastZombieDeathTime < 2000) {
                stopMovement();
                return;
            } else {
                target = null;
            }
        }


        if (target == null || target.isDead) {
            target = findNearestZombie();
        }


        if (target != null) {
            moveToTarget(target);
        } else {

            randomMovement();
        }


        smoothTurn();
        smoothMovement();


        avoidObstacles();

        lastPosition = new Vec3d(mc.player.posX, mc.player.posY, mc.player.posZ);
    }

    @SubscribeEvent
    public void onRenderWorld(RenderWorldLastEvent event) {
        if (!this.isEnabled() || mc.player == null || lastPosition == null) return;


        drawLine(lastPosition, new Vec3d(mc.player.posX, mc.player.posY, mc.player.posZ), 1.0f, 0.0f, 0.0f, 1.0f);
    }

    private void drawLine(Vec3d start, Vec3d end, float r, float g, float b, float a) {

        GlStateManager.disableTexture2D();
        GlStateManager.enableBlend();
        GlStateManager.disableDepth();
        GlStateManager.tryBlendFuncSeparate(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA, 1, 0);
        GlStateManager.color(r, g, b, a);


        Tessellator tessellator = Tessellator.getInstance();
        tessellator.getBuffer().begin(GL11.GL_LINE_STRIP, DefaultVertexFormats.POSITION);


        tessellator.getBuffer().pos(start.x, start.y, start.z).endVertex();
        tessellator.getBuffer().pos(end.x, end.y, end.z).endVertex();


        tessellator.draw();


        GlStateManager.enableDepth();
        GlStateManager.disableBlend();
        GlStateManager.enableTexture2D();
    }

    private Entity findNearestZombie() {

        List<Entity> entities = mc.world.getEntitiesWithinAABB(EntityZombie.class, mc.player.getEntityBoundingBox().grow(20));
        if (entities.isEmpty()) return null;


        Entity nearestZombie = entities.get(0);
        double minDistance = mc.player.getDistance(nearestZombie);
        for (Entity entity : entities) {
            double distance = mc.player.getDistance(entity);
            if (distance < minDistance) {
                minDistance = distance;
                nearestZombie = entity;
            }
        }

        return nearestZombie;
    }

    private void moveToTarget(Entity target) {

        double deltaX = target.posX - mc.player.posX;
        double deltaZ = target.posZ - mc.player.posZ;
        double angle = Math.toDegrees(Math.atan2(deltaZ, deltaX)) - 90;


        targetYaw = (float) angle;


        targetSpeed = 0.2;
    }

    private void randomMovement() {

        if (mc.player.ticksExisted % 20 == 0) {
            targetYaw += (Math.random() - 0.5) * 90;
        }


        targetSpeed = 0.2;
    }

    private void smoothTurn() {

        float deltaYaw = targetYaw - mc.player.rotationYaw;
        while (deltaYaw > 180) deltaYaw -= 360;
        while (deltaYaw < -180) deltaYaw += 360;


        mc.player.rotationYaw += deltaYaw * 0.1f;


        float deltaPitch = targetPitch - mc.player.rotationPitch;
        mc.player.rotationPitch += deltaPitch * 0.1f;
    }

    private void smoothMovement() {

        double currentSpeed = Math.sqrt(mc.player.motionX * mc.player.motionX + mc.player.motionZ * mc.player.motionZ);
        double deltaSpeed = targetSpeed - currentSpeed;


        mc.player.motionX += Math.cos(Math.toRadians(mc.player.rotationYaw)) * deltaSpeed * 0.1;
        mc.player.motionZ += Math.sin(Math.toRadians(mc.player.rotationYaw)) * deltaSpeed * 0.1;
    }

    private void avoidObstacles() {

        RayTraceResult rayTrace = mc.world.rayTraceBlocks(
                mc.player.getPositionEyes(1.0F),
                mc.player.getPositionEyes(1.0F).add(mc.player.getLookVec().scale(5)) // Конечная точка (5 блоков вперед)
        );


        if (rayTrace != null && rayTrace.typeOfHit == RayTraceResult.Type.BLOCK) {
            isAvoidingObstacle = true;

            if (Math.random() < 0.5) {
                targetYaw -= 45;
            } else {
                targetYaw += 45;
            }
        } else {
            isAvoidingObstacle = false;
        }
    }

    private void stopMovement() {

        mc.player.motionX = 0;
        mc.player.motionZ = 0;
        targetSpeed = 0;
    }
}