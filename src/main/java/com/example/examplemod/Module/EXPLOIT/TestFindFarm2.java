package com.example.examplemod.Module.EXPLOIT;

import com.example.examplemod.Module.Module;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.entity.Entity;
import net.minecraft.entity.monster.EntityZombie;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.client.event.RenderWorldLastEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;
import org.lwjgl.input.Keyboard;
import org.lwjgl.opengl.GL11;

import java.util.Comparator;
import java.util.List;

public class TestFindFarm2 extends Module {
    public TestFindFarm2() {
        super("FindFarm (New)", Keyboard.KEY_NONE, Category.EXPLOIT);
    }

    private final Minecraft mc = Minecraft.getMinecraft();
    private Entity target = null;
    private long lastZombieDeathTime = 0;
    private float targetYaw = 0;
    private double targetSpeed = 0.4;
    private Vec3d lastPosition = null;

    private double searchRadius = 30.0;
    private double movementSpeed = 0.2;
    private float smoothTurnFactor = 0.1f;

    @SubscribeEvent
    public void onPlayerTick(TickEvent.PlayerTickEvent event) {
        if (!this.isEnabled() || mc.player == null || mc.world == null) return; // Проверяем, включен ли модуль


        if (target != null && target.isDead) {
            if (System.currentTimeMillis() - lastZombieDeathTime < 2000) {
                stopMovement();
                return;
            } else {
                target = null;
            }
        }


        if (target == null || target.isDead) {
            target = findNearestZombie();
        }


        if (target != null) {
            moveToTarget(target);
        } else {

            randomMovement();
        }


        smoothTurn();
        smoothMovement();


        avoidObstacles();


        lastPosition = new Vec3d(mc.player.posX, mc.player.posY, mc.player.posZ);
    }

    @SubscribeEvent
    public void onRenderWorld(RenderWorldLastEvent event) {
        if (!this.isEnabled() || mc.player == null || lastPosition == null) return;


        drawLine(lastPosition, new Vec3d(mc.player.posX, mc.player.posY, mc.player.posZ), 1.0f, 0.0f, 0.0f, 1.0f);
    }

    private void drawLine(Vec3d start, Vec3d end, float r, float g, float b, float a) {
        if (start.equals(end)) return;

        GlStateManager.disableTexture2D();
        GlStateManager.enableBlend();
        GlStateManager.disableDepth();
        GlStateManager.tryBlendFuncSeparate(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA, 1, 0);
        GlStateManager.color(r, g, b, a);
        Tessellator tessellator = Tessellator.getInstance();
        tessellator.getBuffer().begin(GL11.GL_LINE_STRIP, DefaultVertexFormats.POSITION);
        tessellator.getBuffer().pos(start.x, start.y, start.z).endVertex();
        tessellator.getBuffer().pos(end.x, end.y, end.z).endVertex();
        tessellator.draw();
        GlStateManager.enableDepth();
        GlStateManager.disableBlend();
        GlStateManager.enableTexture2D();
    }

    private Entity findNearestZombie() {

        List<Entity> zombies = mc.world.getEntitiesWithinAABB(EntityZombie.class, mc.player.getEntityBoundingBox().grow(searchRadius));


        return zombies.stream()
                .min(Comparator.comparingDouble(entity -> mc.player.getDistance(entity)))
                .orElse(null);
    }

    private void moveToTarget(Entity target) {

        double deltaX = target.posX - mc.player.posX;
        double deltaZ = target.posZ - mc.player.posZ;


        if (isPathClear(target)) {
            double angle = Math.toDegrees(Math.atan2(deltaZ, deltaX)) - 90;
            targetYaw = (float) angle;
            targetSpeed = movementSpeed;
        } else {

            targetYaw += (Math.random() < 0.5) ? -15 : 15;
        }
    }

    private boolean isPathClear(Entity target) {
        Vec3d start = mc.player.getPositionEyes(1.0F);
        Vec3d end = new Vec3d(target.posX, target.posY, target.posZ);
        RayTraceResult result = mc.world.rayTraceBlocks(start, end);
        return result == null || result.typeOfHit != RayTraceResult.Type.BLOCK;
    }

    private void randomMovement() {

        if (mc.player.ticksExisted % 20 == 0) {
            targetYaw += (Math.random() - 0.5) * 360;
        }


        targetSpeed = movementSpeed;
    }

    private void smoothTurn() {

        float deltaYaw = targetYaw - mc.player.rotationYaw;
        while (deltaYaw > 180) deltaYaw -= 360;
        while (deltaYaw < -180) deltaYaw += 360;

        mc.player.rotationYaw += deltaYaw * smoothTurnFactor;


    }

    private void smoothMovement() {

        double currentSpeed = Math.sqrt(mc.player.motionX * mc.player.motionX + mc.player.motionZ * mc.player.motionZ);
        double deltaSpeed = targetSpeed - currentSpeed;


        mc.player.motionX += Math.cos(Math.toRadians(mc.player.rotationYaw)) * deltaSpeed * 0.1;
        mc.player.motionZ += Math.sin(Math.toRadians(mc.player.rotationYaw)) * deltaSpeed * 0.1;
    }

    private void avoidObstacles() {

        Vec3d[] rays = {
                mc.player.getLookVec().scale(5),
                mc.player.getLookVec().rotateYaw((float) Math.toRadians(-45)).scale(5),
                mc.player.getLookVec().rotateYaw((float) Math.toRadians(45)).scale(5),
                mc.player.getLookVec().rotateYaw((float) Math.toRadians(90)).scale(5),
                mc.player.getLookVec().rotateYaw((float) Math.toRadians(-90)).scale(5)
        };

        boolean obstacleDetected = false;

        for (Vec3d ray : rays) {
            RayTraceResult rayTrace = mc.world.rayTraceBlocks(
                    mc.player.getPositionEyes(1.0F),
                    mc.player.getPositionEyes(1.0F).add(ray)
            );

            if (rayTrace != null && rayTrace.typeOfHit == RayTraceResult.Type.BLOCK) {
                obstacleDetected = true;
                break;
            }
        }

        if (obstacleDetected) {
            targetYaw += (Math.random() < 0.5) ? -45 : 45;
        }
    }

    private void stopMovement() {

        targetSpeed = 0;
        mc.player.motionX *= 0.5;
        mc.player.motionZ *= 0.5;
    }
}